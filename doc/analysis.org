
* Introduction

  The present document contains the specifications of a protocol for
p2p trade of cryptography secured tokens that can represent arbitrary
assets such as complementary currencies to enable inter-trade between
them.

This protocol supports tokens that only exist in certain databases
and also tokens that exist publicly in a p2p accounting network such
as Bitcoin. That network protocol has to be extended to be compatible
with this protocol. FreiMarkets is an extension of the Freicoin
protocol to support this protocol.

* Definitions

- *Asset*: a crypto-token type representing a certain type of
  property.

- *Transitive transaction*: an atomic transaction involving more
  than two assets. This is similar to Ryan Fugger's Ripple concept.
  Transitive transactions can involve an arbitrary number of assets,
  allowing the payer to use a different currency than the one the
  recipient will receive. This allows economic agents without a
  direct trust relationship to interact with each other.

- *The payer*: the initiator of a transitive transaction, no matter
  if it is a payment or trade.

- *Crypto-chain*: the data structure that contains the information of
  a p2p accounting network (for example, Freicoin's blockchain).

- *Public asset*: an asset that exists in a crypto-chain.

- *Private asset*: an asset that exists in a private server.

- *Commit*: the process by which a transaction becomes irrevocably
  valid and all the movements of asset are atomically executed. 
  
  The protocol must support different commit methods and be
  extendable in that respect. The main commit methods are
  crypto-chain commit and registry commit. All transactions involving
  public assets have to use the crypto-chain commit method. In fact,
  transactions involving only public assets don't need to do anything
  special for the commit, just be valid when they get into the chain.

- *Holder*: a user that owns certain quantity of a given asset.

- *Issuer*: the entity responsible for a given asset. Only the
  issuer can create new units of a given asset and it is also
  responsible for the real world backing of the asset if it has any.

- *Accountant*: a server responsible for the accounting of a given
  asset. It has to maintain a database of the balances and prevent
  the double-spending of the tokens, thus its signature is required
  for every transaction involving an asset it accounts for. For this
  reason accountants are supposed to be always online. An issuer can
  also act as its own accountant. 

  Since the crypto-chain does the accounting and double-spending
  prevention on its own, public assets don't have any accountant.

- *Authority*: a server that verifies and signs all attempted
  transactions, orders and promises involving a given asset. They are
  optional for both public and private assets.
  
  They can limit, for example, which addresses can hold the asset to
  a set of authorized accounts defined by the issuer or the Authority itself.
  Certain assets need an authority to comply with money transmission
  regulations or to enable a higher level o transparency using only
  verified addresses that belong to known parties. They can maintain
  a full provable log of all transactions involving the asset.

  Although it would be reasonable to assume that they will be always
  online, they can sign transactions and orders in advance, being the
  accountant the only actor that always needs to sign at transaction
  processing time.

  An issuer can act as its own Authority.

- *Order*: a binding offer to to exchange certain quantity
  of an asset for another asset at given price or rate. They're
  signed by the holder and the authority of the asset being sold.

  Depending on the nature of the assets being traded, orders can be
  public, private or mixed. Orders offering a private asset for a
  public one are considered private, only orders that give a public
  asset in exchange of private assets are considered mixed.

  Transactions including public and/or mixed orders must be committed
  using the crypto-chain commit method because they involve public
  assets.

- *Registry commit method*: when all assets in the transaction are
  private, the registry commit method can be used. 

  After collecting the necessary orders, the payer initiates the
  transaction by specifying a registry (this may need previous
  negotiation between the payer and the accountants), creating a
  random commit secret and distributing its hash and an expiry
  timestamp to the different accountants. The payer also sends the
  amount to be filled from each order to the accountants, which sign
  the orders appending the information received. Once signed by the
  accountants, the orders constitute "promises".

  Once everything is signed, the payer sends the commit secret to the
  specified registry, which signs the secret appending a tiemstamp
  with the current time. Anyone can query the register for a specified
  secret hash and the register will answer the with the secret and the
  timestamp or a message indicating that the secret has not been
  processed yet.

  The promises and the proof from the register constitute together
  the proof of payment.

- *Crypto-chain commit method*: when there's public and private assets
  in a transaction, the chain commit method must be used. If all the
  assets are private, a public asset can be used paying a fee to use
  this commit method.

  After collecting the necessary orders, the payer builds

--------------------------

- All public + chain: get into the chain valid (before all expiry's)
- All private + registry: payer's commit secret timestamped by
  registry before tx_expiry.
- All private + chain: 
  + payer's commit secret timestamped by registry before tx_expiry_block ??
  + pub_tx's id gets into the chain (transaction has n_expiry_time. ??
- Mixed + chain: 

-----------------  

  When private assets are being sold, the payer initiates the
  transaction by creating a random secret and distributes its hash to
  the different accountants. They sign the order with the secret hash 


- *Registry*: a server providing a timestamping service to ensure
  atomicity in non-trivial transactions (involving more than one
  asset) that aren't committed using a crypto-chain. Any transaction
  involving public assets must be committed using its crypto-chain
  and therefore doesn't need a registry.

  The registry doesn't have to know anything about the transaction
  itself apart the commit secret, the commit secret hash and the
  timestamp. It publishes tuples with these three elements. It doesn't
  even know if the transaction was valid or it expired.

- *Promise*: A signed sub-transaction which validity depends on the
  commit of the full transaction by a registry or a crypto-chain.
  They contain the hash of a commit secret in the case of purely
  private transactions which are to be committed by a registry. If
  the transaction is partially public, they contain a hash of the
  full public transaction (before signatures are added) instead of
  the commit secret.

  They must contain an expiry timestamp for registry commits. In the
  case of crypto-chain commits, the public part of the transaction
  must contain the expiry time in its own format (for example, in the
  case of Freicoin the expiry time would be expressed as a block
  number).

- **: 

- **: 

- **: 

- **: 

- **: 

- **: 

* Messages

  The following message types define the protocol. Although this
  document uses JSON nomenclature to define the messages, the
  protocol itself could use another data serialization format.

** Private asset definition

#+BEGIN_SRC json
"asset_definition": {
    "issuer": "(hash of the issuer's public key)",
    "accountant": "(optional, hash of the accountant's public key)",
    "commit_methods": [(commit methods)],
    "interest_rate": "(interest rate, may be negative)",
    "interest_step": "(time in seconds)",
    "unit": "(optional, value unit)",
    "contract": "(optional, private contract associated with the asset)"
}
#+END_SRC

   If the accountant field is left empty, the issuer himself
   acts like an accountant for the asset.

   Each interest_step in seconds, interest_rate is applied.

   The private contract may be a legal contract or something that
   enables more automatic features like a ricardian contract.

** Advertisement



* Examples
** 
* Sequences
