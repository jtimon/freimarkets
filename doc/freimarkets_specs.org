#+TITLE: FreiMarkets: credit, assets, and p2p exchange
#+AUTHOR:
#+EMAIL:
#+KEYWORDS: p2p exchange, crypto-assets, crypto-credit, smart property, colored coins, ripple, off-chain transactions, cross-chain trade
#+LANGUAGE: en
#+LaTeX_CLASS: article
#+LATEX_HEADER: \usepackage[T1]{fontenc}
#+LATEX_HEADER: \usepackage[margin=2.5cm,includefoot]{geometry}
#+LATEX_HEADER: \usepackage{graphicx}
#+LATEX_HEADER: \usepackage{pict2e}
#+LATEX_HEADER: \usepackage{amsmath}
#+LATEX_HEADER: \usepackage{chngcntr}
#+LATEX_HEADER: \usepackage{hyperref}
#+LATEX_HEADER: \usepackage{import}
#+LATEX_HEADER: \hypersetup{colorlinks,citecolor=green,filecolor=black,linkcolor=blue,urlcolor=blue}
#+OPTIONS:     toc:nil H:5
#+BIND: org-export-latex-title-command ""

#+TODO: TODO MODIFY DELETE | REVIEW DONE

Adding arbitrary, user-specified bearer instruments, off-chain accounting, atomic trades, auctions, and transitive transactions to Freicoin

* Introduction

  Herein we propose a new transaction format, nVersion=3 transactions, which enables hierarchies of independently verified sub-transactions, additional validation scripts and introspective opcodes, strict currency controls, as well as relaxation of the rules regarding coin generation via coinbase transactions for the purpose of supporting user-defined assets on the block-chain. We also introduce the concept of private centralized accounting servers to perform transactions of off-chain assets that can interact with each other as well as with in-chain assets. Combined with suitable extensions to the peer-to-peer, JSON-RPC, RESTful, and wallet interfaces, these protocol changes complete bitcoin’s repertoire of low-level constructs, allowing the emulation of a wide variety of financial instruments.

  Together this enables the following sorts of applications:

- Issuing new assets by means of asset definition transactions (coinbase transactions other than the usual first transaction of a block). Such assets are allowed to specify their own interest/demurrage rate, unit granularity, and display scale. As well as a hash field referencing an external resource, possibly a legal or ricardian contract that the chain itself doesn't have to validate.

- Issuing unique and indivisible tokens that are transferred in sets instead of numeric amount, and allow fast look ups on their current ownership to enhance smart property use cases and manage some permissions of the regular custom assets.

- Atomic exchange of assets of differing types through inclusion of inputs and outputs of both types in a single transaction.

- Signing orders (partial-transactions giving up one asset in exchange for another) that are binding but not completed until they get into the chain as part of a balanced transaction, and have attached expiration dates or can be explicitly cancelled by double-spending the signed inputs.

- Executing an arbitrary number of these orders atomically by creating a complete valid transaction where the orders are included as nested sub-transactions, thereby executing an atomic trade without requiring each of the parties to be online or in direct communication with each other. Composing orders from separate markets into an atomic trade with intermediate assets enables payments based on transitive trust relationships.

- Destruction of coins, tokens, or assets when no longer needed by a special class of non-spendable, prunable output script.

- Restricting the conditions by which a transaction or sub-transaction may be selected for inclusion by specifying validation scripts, which are run when the enclosing block is validated. Introspection of the block chain from within the bitcoin scripting environment is enabled by the introduction of new opcodes.

- Running accounting servers as private chains with centralized rather than distributed consensus, in which off-chain assets can be issued, transferred and traded in the same way they are in the public chain, with the private block chain providing an audit log.

- Execute an arbitrary number of trades from different accounting servers and/or the public chain in an atomic transaction, using either the public chain or an agreed upon centralized timestamping service for the commit phase.

- Public chains or private accounting servers configured to “observe” other chains to enable much faster but secure cross-chain trade, compared with the existing slow, multi-phase protocols involving revelation of hashed secrets. This requires the ability to extract proofs from the observed chain in order to validate conditional transactions.

- Restrict the usage of a custom asset by assigning to it rotatable signing keys which must sign all transactions involving the restricted assets prior to inclusion (support for KYC regulatory compliance).

  This proposal adds primitives to bitcoin necessary for implementing non-currency financial constructs, such as dividend-yielding bonds, asset ownership tokens, credit relationships, a variety of forms of smart contracts, and distributed marketplaces for exchanging all of the above. Private accounting servers provide a mechanism to support unlimited volume of off-chain transactions while being able to interact with in-chain assets through atomic cross-chain trade and an integrated peer-to-peer market.

* Description

  Here we describe in non-normative prose the proposed changes. We assume technical familiarity with the bitcoin protocol and Freicoin’s various extensions thereof.

** A note on units

   Throughout this document a couple of differing units are used for describing financial quantities on the Freicoin block chain. This unfortunate confusing situation arises from the history of representing bitcoin/freicoin amounts both in user interface and serialization formats.

   When talking about the host currency we speak of freicoins, with 1 freicoin (1 frc) traditionally being specified with 8 decimal places of precision. In old-style transactions the smallest non-zero representable unit of freicoins is 1 kria, with 100,000,000 kria = 1 frc. New-style transactions encode freicoin quantities as decimal64 values, with 1 kria = 10^369, and the smallest non-zero representable unit being 10^-398 or 10^-775 frc. In either case, it is expected that the user interface will be configured to show units of freicoins, or the multiplier of the underlying asset, if specified.

** Indivisible, unique tokens

   Indivisible, uniquely identifiable asset tokens are useful for applications like physical ownership - keys to a smart car, numbered seats or membership tokens. Since an indivisible is contained within no more than one unspent transaction output at any given time, it’s not necessary to trace the ownership back to a “genesis transaction” as one would need to do with a colored coins approach [fn:colored]. This allows smart property clients to have smaller requirements if authenticated unspent transaction output index checkpoints are included in each block [fn:utxo].

** User-issued assets

   Divisible currency and/or tokens representing user-issued assets may be minted in special coinbase transactions separate from the usual first transaction of a block (where freicoins are currently, and continue to be minted). Coins created in such generating transactions are not freicoins, but rather user-issued asset shares which represent fungible ownership of the underlying asset type, or asset tokens identified by per-asset unique bitstrings. Such tokens can be included in transactions containing regular Freicoin currency, which in this document is sometimes called the host currency or fee currency.

   The creator of the new asset can define an interest/demurrage rate. The quantity issued may be fixed or he may define a list of issuance tokens that permit their owners issue new units of the asset being defined.

   The creator of the asset definition transaction may also specify a list of authorizer tokens. The signature of an authorizer is required every time a transaction involves inputs or outputs of that asset. This allows issuers/gateways to manage closed list of “authorized accounts” of registered users if regulatory restrictions of their jurisdiction requires them to do so [fn:kyc] or if they desire whitelisting of participants (for example, local currencies or restricted stock sales). It also allows issuers to charge fees when the assets are traded or moved.

   Using unique tokens to manage new issuance and authorizers allows the creator to follow his own key cycling policy or security protocols. By utilizing multisig or multiple signatures, it is possible for transactions to remain valid even across one or more key rotations.

   These various properties of the asset, its interest/demurrage rate, unit granularity and display scale, the external contract and listings of issuer and authorizer tokens are set in the coinbase string of the asset definition transaction.

** Partial transactions

   This proposal extends the transaction format with an optionally empty nested level of sub-transactions. Sub-transactions differ from regular, top-level transactions in that their inputs and outputs are not required to balance and they have associated with them a quantity and granularity allowing for fractional redemption.

   Since validation of sub-transactions occurs separately from each other and the higher-level enclosing transaction, pre-signed, unbalanced transactions are able to act as offers on a distributed exchange: market participants sign offers adding coins of one asset type in exchange for an output of another type. These signed offers are broadcast through a side-channel and aggregated by miners. When a cross-over is detected (a bid higher than an ask), the miner combines the two pre-signed offers and claims the difference as a fee.

** Private ledgers

   Private accounting servers (the “accountant”) use a variant of the Freicoin/Freimarkets code base that is stripped of the distributed consensus proof-of-work mechanism. Accountants are responsible for eliminating double-spending, reserving balances for pending transfers, and authorizing transactions, sometimes conditionally on external events. Accountants are able to prevent transactions from going through if the owner has already obligated funds elsewhere, by keeping track of the available balance (actual balance minus funds in various stages of commit). Accountants use various distributed consensus mechanisms for coordinating the transaction commitment with other private accounting servers or public block chains.

   The level of privacy may vary from one server to another. Server operators are allowed freedom in choosing which parts of the block chain audit log to publish, with a sensible default being the block headers and coinbase transactions, allowing for validation of authenticated inclusion and index proofs used to notify users of their wallet balance, history and current activity, but not revealing other user’s balances.

   By using newly added introspective opcodes to construct scripts dependent on external chains, it is possible for private transactions to be conditional on public Freicoin blockchain data or other private accounting servers.

   (Note that the opposite relation cannot apply at this time.. Public chains could support transactions conditional to data on other chains to enhance cross-chain trade, but then the observing chain’s validation becomes dependent on the observed chain validation and more sensible to reorgs. This approach to cross-chain has been described several times [fn:mdc], and would be trivial to implement with this protocol extension.)

* TODO Formal specification
** nVersion=3 transactions

** Unique asset definitions and transfers
indivisibles : the simplist method is for outputs to contain instead of an int64 nValue, a decimal64 nValue + varlist(uniques)
** Asset definition transactions
** Sub-transactions
** Validation scripts
** New scripting opcodes
* Example use cases and Bitcoin scripts
** MODIFY Private buy with public funds
   Seller constructs private order:

#+BEGIN_SRC bitcoin
in: 100 privB
out: 100 FRC:pubA to seller1
validation scriptPubKey:
    OP_DELEGATION_SEPARATOR OP_DUP OP_HASH160 <accountantB_pkh> OP_EQUALVERIFY OP_CHECKSIGVERIFY_DEL
    OP_FROMALTSTACK (expiry) OP_FROMALTSTACK (amount) seller1 pubA FRC_CHAIN_ID OP_OUTPUT_EXISTS_BEFORE
#+END_SRC

   ...and signs the partial transaction.

   The validation script starts with OP_DELEGATION_SEPARATOR, which is simply ignored by the script interpreter, but marks the part of the validation script that needs to be signed by the owners of the inputs in the transaction or sub-transaction, the rest

   Note that there's some data being fetch from the stack, that data must be set by accountantB or the script will return false if it's not in the stack. Whoever appears in OP_CHECKSIGVERIFY_DEL (in this case accountantB) must sign the full transaction with the complete validation script that can be valid, including what's after OP_DELEGATION_SEPARATOR.

   Note also that he output refers to an external asset (FRC:pubA) accountantB has no control over. It is ignored for validation purposes and is only used to specify the exchange rate. If the accountant cheats the user with the exchange rate, there will be a proof of fraud.

   The payer (who just wants 50 privB) completes the private transaction with:

#+BEGIN_SRC bitcoin
in: -
out: 50 privB to buyer1
#+END_SRC

   The buyer also creates the public transaction:

#+BEGIN_SRC bitcoin
in: 50 pubA
out: 50 pubA to seller1
expiry: 10000
#+END_SRC

   ...but doesn't sign it. It sends both complete but not signed transactions to the accountant who reads them and completes the private validation scriptPubKey with:

#+BEGIN_SRC bitcoin
50 OP_TOALTSTACK 10000 OP_TOALTSTACK
#+END_SRC

   Finally accountantB signs it all and fills the sub-tx validation scriptSig with:

#+BEGIN_SRC bitcoin
<accountantB_sig> <accountantB_pk>
#+END_SRC

   If you put the full script ordered together to validate by the script interpreter you have:

#+BEGIN_SRC bitcoin
<accountantB_sig> <accountantB_pk>
50 OP_TOALTSTACK 10000 OP_TOALTSTACK
CODE_SEPARATOR OP_DUP OP_HASH160 <accountantB_pkh> OP_EQUALVERIFY OP_CHECKSIGVERIFY
OP_FROMALTSTACK OP_FROMALTSTACK seller1 pubA FRC_CHAIN_ID OP_OUTPUT_EXISTS_BEFORE
#+END_SRC

   Operations in the stack shouldn't be allowed in the validation scriptSig for this to be secure.

   Now if buyer1 signs the public transaction and it gets into the FRC chain before height 10000, the private transaction will be valid. Until that happens or height 10000 is reached the transaction is considered to be in process and after height 10000 without appearance of the public one, the private transaction is invalid.

** MODIFY Buying public assets with private assets

   The seller constructs the public order:

#+BEGIN_SRC bitcoin
in: 100 pubB
out: 100 accountantA:privA to seller1
validation scriptPubKey:
    OP_DELEGATION_SEPARATOR OP_DUP OP_HASH160 <accountantA_pkh> OP_EQUALVERIFY OP_CHECKSIGVERIFY_DEL
#+END_SRC

   ...and signs the partial transaction.

   The payer (who just wants 50 pubB) completes the public transaction with:

#+BEGIN_SRC bitcoin
in: -
out: 50 pubB to buyer1
expiry: 10000
#+END_SRC

   The buyer also creates the private transaction:

#+BEGIN_SRC bitcoin
in: 50 privA
out: 50 privA to seller1
validation scriptPubKey:
    10000 50 buyer1 pubB FRC_CHAIN_ID OP_OUTPUT_EXISTS_BEFORE
#+END_SRC

   The buyer signs the private transaction and sends it with the public one to accountantA.
The public transaction only lacks accountantA's signature to be valid. If the public transaction gets into the chain before 10000 the private one is also valid, otherwise is rolled back.

** MODIFY Hybrid Transitive transaction

   pubA -> pubB -> privC -> privD -> pubE -> userA

   So the payer (userA) will pay pubA and receive pubE in exchange. PrivCs and privDs are managed by accountants accC and accD respectively.

Opened offers:

   1 ) Fully public:

#+BEGIN_SRC bitcoin bitcoin
in: 100 pubB
out: 100 pubA to userB
#+END_SRC

   2 ) Private for Public:

#+BEGIN_SRC bitcoin
in: 100 privC
out: 100 FRC:pubB to userC
validation scriptPubKey:
    OP_DELEGATION_SEPARATOR OP_DUP OP_HASH160 <accountantC_pkh> OP_EQUALVERIFY OP_CHECKSIGVERIFY_DEL
    OP_FROMALTSTACK (expiry) OP_FROMALTSTACK (amount) userC pubB FRC_CHAIN_ID OP_OUTPUT_EXISTS_BEFORE
#+END_SRC

   3 ) Private for private:

#+BEGIN_SRC bitcoin
in: 100 privD
out: 100 accC:privC to userD
validation scriptPubKey:
    OP_DELEGATION_SEPARATOR OP_DUP OP_HASH160 <accountantC_pkh> OP_EQUALVERIFY OP_CHECKSIGVERIFY_DEL
    OP_DUP OP_HASH160 <accountantD_pkh> OP_EQUALVERIFY OP_CHECKSIGVERIFY_DEL
#+END_SRC

   4 ) Public for private:

#+BEGIN_SRC bitcoin
in: 100 pubE
out: 100 accD:privD to userE
validation scriptPubKey:
    OP_DUP OP_HASH160 <accountantD_pkh> OP_EQUALVERIFY OP_CHECKSIGVERIFY_DEL
#+END_SRC

   The payer (userA) who wants to buy 50 pubE for 50 pubA builds the public transaction (pub_tx) using offers 1 and 4:

#+BEGIN_SRC bitcoin
in:  50 pubA
out: 50 pubB to userC
     50 pubE to userA
expiry: 10000
#+END_SRC

   Since 50 pubB from offer 1 are used to pay C, 50 pubA must go to userB, and those are funded by userA in the inputs so sub-tx 1 is complete and valid.
   But offer 4 still requires accD to sign the full transaction. UserA still hasn't provided the scriptSig to access those 50 pubA in the inputs neither.

   Two private transactions need to be created:

   Using offer 2, the payer also builds transaction priv_tx_1:

#+BEGIN_SRC bitcoin
in: -
out: 50 privC to userD
#+END_SRC

   The validation scriptPubKey for 2 must be completed pushing 50 as the amount and 10000 as the expiry into the stack. The validity of offer 2 and thus this whole transaction still depends on accC's signature.

   The other private transaction (priv_tx_2) is built using offer 3:

#+BEGIN_SRC bitcoin
in: -
out: 50 privD to userE
validation scriptPubKey:
    10000 50 userC pubB FRC_CHAIN_ID OP_OUTPUT_EXISTS_BEFORE
#+END_SRC

   Offer 3 doesn't require any completion for its validation scriptPubKey, but the corresponding scriptSig requires the signatures of both accC and accD.

   Now that all transactions are complete, it's time to sign.

   First accC signs priv_tx_1 and shares with userA and accD. This is secure because priv_tx_1 still depends 50 pubB being sent to userC.

   UserD is secure because priv_tx_2 in which he gives privD will only be valid if priv_tx_1 is valid too, that is, if 50 pubB are sent to userC before expiry as the validation scriptPubKey of priv_tx_2 requires. So accC and accD can sign offer 3 in any order to make priv_tx_2 almost valid.

   Now accD signs pub_tx to make offer 4 valid.

   Only userA's signature for the 50 pubA input is missing. The payer (userA) signs the full transaction and broadcasts. If it gets into the block before expiry, all transactions are valid, otherwise all of them are invalid.

   At any point, accC, accD or even userA right before the end could stop signing and forwarding the transactions, but that would only cause all transaction to expire.

** TODO Several private assets with blockchain commit method
** TODO Several private assets with registry commit method
** TODO Simplified cross-chain trade contract

* Footnotes

[fn:colored] Colored coins approach to custom assets in the chain is to define a genesis transaction that identifies the asset and trace the funds in that transaction outside of the chain to treat them differently as they represent more than regular bitcoins. This approach has several limitations when compared to this protocol extension. There's a discussion group on colored coins development here: https://groups.google.com/forum/#!forum/bitcoinx

[fn:utxo] Having a fast access UTXO tree indexed in each block would enhance light clients security and it is also important for scalability, something important for this proposal since it enables new uses and a bigger volume is to be expected. Mark Friedenbach's work on these improvements is documented here: http://utxo.tumblr.com/

[fn:kyc] Issuers of currencies convertible to fiat may have to comply with know your customer regulations in their jurisdiction for Ant-Money laundering enforcement. For example, usd gateways based on the US need to comply with [[http://fincen.gov/statutes_regs/guidance/html/FIN-2013-G001.html][FinCEN's normative]].

[fn:mdc] https://bitcointalk.org/index.php?topic=31643.0
https://bitcointalk.org/index.php?topic=91843.0
https://en.bitcoin.it/wiki/Atomic_cross-chain_trading


