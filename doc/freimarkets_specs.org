#+TITLE: FreiMarkets: credit, assets, and p2p exchange
#+AUTHOR:      
#+EMAIL:       
#+KEYWORDS: p2p exchange, crypto-assets, crypto-credit, smart property, colored coins, ripple, off-chain transactions, cross-chain trade
#+LANGUAGE: en
#+LaTeX_CLASS: article
#+LATEX_HEADER: \usepackage[T1]{fontenc}
#+LATEX_HEADER: \usepackage[margin=2.5cm,includefoot]{geometry}
#+LATEX_HEADER: \usepackage{graphicx}
#+LATEX_HEADER: \usepackage{pict2e}
#+LATEX_HEADER: \usepackage{amsmath}
#+LATEX_HEADER: \usepackage{chngcntr}
#+LATEX_HEADER: \usepackage{hyperref}
#+LATEX_HEADER: \usepackage{import}
#+LATEX_HEADER: \hypersetup{colorlinks,citecolor=green,filecolor=black,linkcolor=blue,urlcolor=blue}
#+OPTIONS:     toc:nil H:5
#+BIND: org-export-latex-title-command ""

#+TODO: TODO MODIFY DELETE | REVIEW DONE

Adding arbitrary, user-specified bearer instruments, atomic trades and transitive transactions to Freicoin

* REVIEW Introduction

Herein we propose a new transaction format, nVersion=3 transactions, which enable hierarchies of independently verified sub-transactions, additional validation scripts and introspective opcodes, strict currency controls, as well as relaxation of the rules regarding coin generation via coinbase transactions for the purpose of supporting user-defined assets on the block-chain. It also introduces the concept of private centralized accounting servers to perform transactions of off-chain assets that cam interact with each other as well as with in-chain assets. Combined with suitable extensions to the peer-to-peer, JSON-RPC, RESTful, and wallet interfaces, these protocol changes complete bitcoin’s repertoire of low-level constructs, allowing the emulation of a wide variety of financial instruments.

Together this enables the following sorts of applications:

- Issuing new assets by means of asset definition transactions (coinbase transactions other than the usual first transaction of a block). Such assets are allowed to specify their own adjustable interest/demurrage rate, and reference an external legal contract (typically governing their redemption).

- Issuing unique and indivisible assets that are transferred in sets instead of amounts and allow fast look ups on their current ownership to enhance some smart property use cases and manage some permissions of the regular custom assets.

- Atomic exchange of assets of differing types through inclusion of inputs and outputs of both types in a single transaction.

- Signing orders (partial-transactions giving up one asset in exchange for another) that are binding but not completed until they get into the chain as part of a balanced transaction, and have attached expiration dates or can be explicitly cancelled by double-spending the signed inputs.

- Executing an arbitrary number of these orders atomically by creating a complete valid transaction where the orders are included as nested sub-transactions, thereby executing an atomic trade without requiring each of the parties to be online or in direct contact with each other. Composing orders from separate markets into an atomic trade with intermediate assets enables payments based on transitive trust relationships.

- Destruction of coins or assets when no longer needed by a special class of non-spendable, prunable output script.

- Restricting the conditions by which a transaction or sub-transaction may be selected for inclusion in a block by specifying validation scripts, which are run when a the enclosing block is validated.

- Introspection of the block chain from within the bitcoin scripting environment through the use of new opcodes.

- Running accounting servers as private chains without proof of work in which off-chain assets can be issued, transferred and traded in the same way they are in the public chain.

- Execute an arbitrary number of trades from different accounting servers and/or the public chain in an atomic transaction using the public chain as the base for the secure commit.

- Execute an arbitrary number of trades from different accounting servers but not assets in public chains using an agreed upon centralized timestamping server for the commit.

- A chain implementing this modifications can "observe" other chain to enable secure cross-chain trade without exchanging the hash any secret. This requires the chain to validate all the observed chains in order to validate some conditional transactions.

This proposal adds primitives to bitcoin necessary for implementing non-currency financial constructs, such as dividend-yielding bonds, asset ownership tokens, credit relationships, a variety of forms of smart contracts, and distributed marketplaces for exchanging all of the above.

Off-chain assets provide a mechanism to support unlimited volume while being able to interact with in-chain assets in an integrated p2p market.

* TODO Description

Here we describe in non-normative prose the proposed changes. We assume technical familiarity with the bitcoin protocol and Freicoin’s various extensions thereof.  

** Unique assets
** Asset definition transactions
* TODO Formal specification
** nVersion=3 transactions
** Sub-transactions
** Unique assets coinbases
** Unique assets transfers
** Asset definition transactions
** New scripting opcodes
** Validation scripts
* Example use cases and Bitcoin scripts
** REVIEW Private buy with public funds
Seller constructs private order:

#+BEGIN_SRC bitcoin
in: 100 privB
out: 100 FRC:pubA to seller1
validation scriptPubKey: 
    OP_DELEGATION_SEPARATOR OP_DUP OP_HASH160 <accountantB_pkh> OP_EQUALVERIFY OP_CHECKSIGVERIFY_DEL
    OP_FROMALTSTACK (expiry) OP_FROMALTSTACK (amount) seller1 pubA FRC_CHAIN_ID OP_OUTPUT_EXISTS_BEFORE
#+END_SRC

and signs the partial transaction. 

The validation script starts with OP_DELEGATION_SEPARATOR, which is simply ignored by the script interpreter, but marks the part of the validation script that needs to be signed by the owners of the inputs in the transaction or sub-transaction, the rest 
Note that there's some data being fetch from the stack, that data must be set by accountantB or the script will return false if it's not in the stack. Whoever appears in OP_CHECKSIGVERIFY_DEL (in this case accountantB) must sign the full transaction with the complete validation script that can be valid, including what's after OP_DELEGATION_SEPARATOR.

Note also that he output refers to an external asset (FRC:pubA) accountantB has no control over. It is ignored for validation purposes and is only used to specify the exchange rate. If the accountant cheats the user with the exchange rate, there will be a proof of fraud.

The payer (who just wants 50 privB) completes the private transaction with:

#+BEGIN_SRC bitcoin
in: -
out: 50 privB to buyer1
#+END_SRC

The buyer also creates the public transaction:

#+BEGIN_SRC bitcoin
in: 50 pubA
out: 50 pubA to seller1
expiry: 10000
#+END_SRC

but doesn't sign it. It sends both complete but not signed transactions to the accountant who reads them and completes the private validation scriptPubKey with:

#+BEGIN_SRC bitcoin
50 OP_TOALTSTACK 10000 OP_TOALTSTACK
#+END_SRC

Finally accountantB signs it all and fills the sub-tx validation scriptSig with:

#+BEGIN_SRC bitcoin
<accountantB_sig> <accountantB_pk>
#+END_SRC

If you put the full script ordered together to validate by the script interpreter you have:

#+BEGIN_SRC bitcoin
<accountantB_sig> <accountantB_pk>
50 OP_TOALTSTACK 10000 OP_TOALTSTACK
OP_DELEGATION_SEPARATOR OP_DUP OP_HASH160 <accountantB_pkh> OP_EQUALVERIFY OP_CHECKSIGVERIFY_DEL
OP_FROMALTSTACK OP_FROMALTSTACK seller1 pubA FRC_CHAIN_ID OP_OUTPUT_EXISTS_BEFORE
#+END_SRC

Operations in the stack shouldn't be allowed in the validation scriptSig for this to be secure.

Now if buyer1 signs the public transaction and it gets into the FRC chain before height 10000, the private transaction will be valid. Until that happens or height 10000 is reached the transaction is considered to be in process and after height 10000 without appearance of the public one, the private transaction is invalid. 

** REVIEW Buying public assets with private assets

The seller constructs the public order:

#+BEGIN_SRC bitcoin
in: 100 pubB
out: 100 accountantA:privA to seller1
validation scriptPubKey: 
    OP_DELEGATION_SEPARATOR OP_DUP OP_HASH160 <accountantA_pkh> OP_EQUALVERIFY OP_CHECKSIGVERIFY_DEL
#+END_SRC

and signs the partial transaction. 

The payer (who just wants 50 pubB) completes the public transaction with:

#+BEGIN_SRC bitcoin
in: -
out: 50 pubB to buyer1
expiry: 10000
#+END_SRC

The buyer also creates the private transaction:

#+BEGIN_SRC bitcoin
in: 50 privA
out: 50 privA to seller1
validation scriptPubKey: 
    10000 50 buyer1 pubB FRC_CHAIN_ID OP_OUTPUT_EXISTS_BEFORE
#+END_SRC

The buyer signs the private transaction and sends it with the public one to accountantA.
The public transaction only lacks accountantA's signature to be valid. If the public transaction gets into the chain before 10000 the private one is also valid, otherwise is rolled back.

** REVIEW Hybrid Transitive transaction

pubA -> pubB -> privC -> privD -> pubE -> userA
So the payer (userA) will pay pubA and receive pubE in exchange. PrivCs and privDs are managed by accountants accC and accD respectively.

Opened offers:

1 ) Fully public:

#+BEGIN_SRC bitcoin bitcoin
in: 100 pubB
out: 100 pubA to userB
#+END_SRC

2 ) Private for Public:

#+BEGIN_SRC bitcoin
in: 100 privC
out: 100 FRC:pubB to userC
validation scriptPubKey: 
    OP_DELEGATION_SEPARATOR OP_DUP OP_HASH160 <accountantC_pkh> OP_EQUALVERIFY OP_CHECKSIGVERIFY_DEL
    OP_FROMALTSTACK (expiry) OP_FROMALTSTACK (amount) userC pubB FRC_CHAIN_ID OP_OUTPUT_EXISTS_BEFORE
#+END_SRC

3 ) Private for private:

#+BEGIN_SRC bitcoin
in: 100 privD
out: 100 accC:privC to userD
validation scriptPubKey: 
    OP_DELEGATION_SEPARATOR OP_DUP OP_HASH160 <accountantC_pkh> OP_EQUALVERIFY OP_CHECKSIGVERIFY_DEL
    OP_DUP OP_HASH160 <accountantD_pkh> OP_EQUALVERIFY OP_CHECKSIGVERIFY_DEL
#+END_SRC

4 ) Public for private:

#+BEGIN_SRC bitcoin
in: 100 pubE
out: 100 accD:privD to userE
validation scriptPubKey: 
    OP_DUP OP_HASH160 <accountantD_pkh> OP_EQUALVERIFY OP_CHECKSIGVERIFY_DEL
#+END_SRC

The payer (userA) who wants to buy 50 pubE for 50 pubA builds the public transaction (pub_tx) using offers 1 and 4:

#+BEGIN_SRC bitcoin
in:  50 pubA
out: 50 pubB to userC
     50 pubE to userA
expiry: 10000
#+END_SRC

Since 50 pubB from offer 1 are used to pay C, 50 pubA must go to userB, and those are funded by userA in the inputs so sub-tx 1 is complete and valid.
But offer 4 still requires accD to sign the full transaction.
UserA still hasn't provided the scriptSig to access those 50 pubA in the inputs neither.

Two private transactions need to be created:

Using offer 2, the payer also builds transaction priv_tx_1:

#+BEGIN_SRC bitcoin
in: -
out: 50 privC to userD
#+END_SRC

The validation scriptPubKey for 2 must be completed pushing 50 as the amount and 10000 as the expiry into the stack. The validity of offer 2 and thus this whole transaction still depends on accC's signature.

The other private transaction (priv_tx_2) is built using offer 3:

#+BEGIN_SRC bitcoin
in: -
out: 50 privD to userE
validation scriptPubKey:
    10000 50 userC pubB FRC_CHAIN_ID OP_OUTPUT_EXISTS_BEFORE
#+END_SRC

Offer 3 doesn't require any completion for its validation scriptPubKey, but the corresponding scriptSig requires the signatures of both accC and accD.

Now that all transactions are complete, it's time to sign.

First accC signs priv_tx_1 and shares with userA and accD. This is secure because priv_tx_1 still depends 50 pubB being sent to userC.

UserD is secure because priv_tx_2 in which he gives privD will only be valid if priv_tx_1 is valid too, that is, if 50 pubB are sent to userC before expiry as the validation scriptPubKey of priv_tx_2 requires.
So accC and accD can sign offer 3 in any order to make priv_tx_2 almost valid.

Now accD signs pub_tx to make offer 4 valid.
Only userA's signature for the 50 pubA input is missing.
The payer (userA) signs the full transaction and broadcasts. If it gets into the block before expiry, all transactions are valid, otherwise all of them are invalid.

At any point, accC, accD or even userA right before the end could stop signing and forwarding the transactions, but that would only cause all transaction to expire.

** TODO Several private assets with blockchain commit method
** TODO Several private assets with registry commit method

