#+TITLE: FreiMarkets: credit, assets, and p2p exchange
#+AUTHOR:
#+EMAIL:
#+KEYWORDS: p2p exchange, crypto-assets, crypto-credit, smart property, colored coins, ripple, off-chain transactions, cross-chain trade
#+LANGUAGE: en
#+LaTeX_CLASS: article
#+LATEX_HEADER: \usepackage[T1]{fontenc}
#+LATEX_HEADER: \usepackage[margin=2.5cm,includefoot]{geometry}
#+LATEX_HEADER: \usepackage{graphicx}
#+LATEX_HEADER: \usepackage{pict2e}
#+LATEX_HEADER: \usepackage{amsmath}
#+LATEX_HEADER: \usepackage{chngcntr}
#+LATEX_HEADER: \usepackage{hyperref}
#+LATEX_HEADER: \usepackage{import}
#+LATEX_HEADER: \hypersetup{colorlinks,citecolor=green,filecolor=black,linkcolor=blue,urlcolor=blue}
#+OPTIONS:     toc:nil H:5
#+BIND: org-export-latex-title-command ""

#+TODO: TODO MODIFY DELETE | REVIEW DONE

Adding arbitrary, user-specified bearer instruments, off-chain
accounting, atomic trades, auctions, and transitive transactions to
Freicoin

* Introduction

Herein we propose a new transaction format, ~nVersion=3~ transactions,
which enables hierarchies of independently verified sub-transactions,
additional validation scripts and introspective opcodes, strict
currency controls, as well as relaxation of the rules regarding coin
generation via coinbase transactions for the purpose of supporting
user-defined assets on the block-chain. We also introduce the concept
of private centralized accounting servers to perform transactions of
off-chain assets that cam interact with each other as well as with
in-chain assets. Combined with suitable extensions to the
peer-to-peer, JSON-RPC, RESTful, and wallet interfaces, these protocol
changes complete bitcoin’s repertoire of low-level constructs,
allowing the emulation of a wide variety of financial instruments.

Together this enables the following sorts of applications:

- Issuing new assets by means of asset definition transactions
  (coinbase transactions other than the usual first transaction of a
  block). Such assets are allowed to specify their own
  interest/demurrage rate, unit granularity, and display scale. As
  well as a hash field referencing an external resource, possibly a
  legal or ricardian contract that the chain itself doesn't have to
  validate.

- Issuing unique and indivisible tokens that are transferred in sets
  instead of numeric amount, and allow fast look ups on their current
  ownership to enhance smart property use cases and manage some
  permissions of the regular custom assets.

- Atomic exchange of assets of differing types through inclusion of
  inputs and outputs of both types in a single transaction.

- Signing orders (partial-transactions giving up one asset in exchange
  for another) that are binding but not completed until they get into
  the chain as part of a balanced transaction, and have attached
  expiration dates or can be explicitly cancelled by double-spending
  the signed inputs.

- Executing an arbitrary number of these orders atomically by creating
  a complete valid transaction where the orders are included as nested
  sub-transactions, thereby executing an atomic trade without
  requiring each of the parties to be online or in direct
  communication with each other. Composing orders from separate
  markets into an atomic trade with intermediate assets enables
  payments based on transitive trust relationships.

- Destruction of coins, tokens, or assets when no longer needed by a
  special class of non-spendable, prunable output script.

- Restricting the conditions by which a transaction or sub-transaction
  may be selected for inclusion by specifying validation scripts,
  which are run when the enclosing block is validated. Introspection
  of the block chain from within the bitcoin scripting environment is
  enabled by the introduction of new opcodes.

- Running accounting servers as private chains with centralized rather
  than distributed consensus, in which off-chain assets can be issued,
  transferred and traded in the same way they are in the public chain,
  with the private block chain providing an audit log.

- Execute an arbitrary number of trades from different accounting
  servers and/or the public chain in an atomic transaction, using
  either the public chain or an agreed upon centralized timestamping
  service for the commit phase.

- Public chains or private accounting servers configured to “observe”
  other chains to enable much faster but secure cross-chain trade,
  compared with the existing slow, multi-phase protocols involving
  revelation of hashed secrets. This requires the ability to extract
  proofs from the observed chain in order to validate conditional
  transactions.

- Restrict the usage of a custom asset by assigning to it rotatable
  signing keys which must sign all transactions involving the
  restricted assets prior to inclusion (support for KYC regulatory
  compliance).

This proposal adds primitives to bitcoin necessary for implementing
non-currency financial constructs, such as dividend-yielding bonds,
asset ownership tokens, credit relationships, a variety of forms of
smart contracts, and distributed marketplaces for exchanging all of
the above. Private accounting servers provide a mechanism to support
unlimited volume of off-chain transactions while being able to
interact with in-chain assets through atomic cross-chain trade and an
integrated peer-to-peer market.

** A note on units

Throughout this document a couple of differing units are used for
describing financial quantities on the Freicoin block chain. This
unfortunate confusing situation arises from the history of
representing bitcoin/freicoin amounts both in user interface and
serialization formats.

When talking about the host currency we speak of freicoins, with 1
freicoin (1 frc) traditionally being specified with 8 decimal places
of precision. In old-style transactions the smallest non-zero
representable unit of freicoins is 1 kria, with 100,000,000 kria = 1
frc. New-style transactions encode freicoin quantities as =decimal64=
values, with 1 kria = 10^369, and the smallest non-zero representable
unit being 10^{-398} or 10^{-775} frc. In either case, it is expected
that the user interface will be configured to show units of freicoins,
or the multiplier of the underlying asset, if specified.

* Major features

Here we describe in non-normative prose the proposed changes. We
assume technical familiarity with the bitcoin protocol and Freicoin’s
various extensions thereof.

** Indivisible, unique tokens

Indivisible, uniquely identifiable asset tokens are useful for
applications like physical ownership - keys to a smart car, numbered
seats or membership tokens. Since a token is contained within no more
than one unspent transaction output at any given time, it’s not
necessary to trace the ownership back to a “genesis transaction” as
one would need to do with a colored coins approach [fn:colored]. This
allows smart property clients to have smaller requirements when
authenticated unspent transaction output index checkpoints are
included in each block [fn:utxo].

** User-issued assets

Divisible currency and/or tokens representing user-issued assets may
be minted in special coinbase transactions separate from the usual
first transaction of a block (where freicoins are currently, and
continue to be minted). Coins created in such generating transactions
are not freicoins, but rather user-issued asset shares which represent
fungible ownership of the underlying asset type, or asset tokens
identified by per-asset unique bitstrings. Such tokens can be included
in transactions containing regular Freicoin currency, which in this
document is sometimes called the host currency or fee currency.

The creator of the new asset can define an interest/demurrage rate.
The quantity issued may be fixed or he may define a list of issuance
tokens that permit their owners issue new units of the asset being
defined.

The creator of the asset definition transaction may also specify a
list of authorizer tokens. The signature of an authorizer is required
every time a transaction involves inputs or outputs of that asset.
This allows issuers/gateways to manage closed list of “authorized
accounts” of registered users if regulatory restrictions of their
jurisdiction requires them to do so [fn:kyc] or if they desire
whitelisting of participants (for example, local currencies or
restricted stock sales). It also allows issuers to charge fees when
the assets are traded or moved.

Using unique tokens to manage new issuance and authorizers allows the
creator to follow his own key cycling policy or security protocols. By
utilizing multisig or multiple signatures, it is possible for
transactions to remain valid even across one or more key rotations.

These various properties of the asset, its interest/demurrage rate,
unit granularity and display scale, and listings of issuer and
authorizer tokens are set in the coinbase string of the asset
definition transaction.

** Partial transactions

This proposal extends the transaction format with an optionally empty
nested level of sub-transactions. Sub-transactions differ from
regular, block-level transactions in that their inputs and outputs are
not required to balance and they have associated with them a quantity
and granularity allowing for fractional redemption.

Since validation of sub-transactions occurs separately from each other
and the higher-level enclosing transaction, pre-signed, unbalanced
transactions are able to act as offers on a distributed exchange:
market participants sign offers adding coins of one asset type in
exchange for an output of another type. These signed offers are
broadcast through a side-channel and aggregated by miners. When a
cross-over is detected (a bid higher than an ask), the miner combines
the two pre-signed offers and claims the difference as a fee.

** Private ledgers

Private accounting servers, or “accountants” use a variant of the
Freicoin/Freimarkets code base that is stripped of the distributed
consensus proof-of-work mechanism. Accountants are responsible for
eliminating double-spending, reserving balances for pending transfers,
and authorizing transactions, sometimes conditionally on external
events. Accountants are able to prevent transactions from going
through if the owner has already obligated funds elsewhere, by keeping
track of the available balance (actual balance minus funds in various
stages of commit). Accountants use various distributed consensus
mechanisms for coordinating the transaction commitment with other
private accounting servers or public block chains.

The level of privacy may vary from one server to another. Server
operators are allowed freedom in choosing which parts of the block
chain audit log to publish, with a sensible default being the block
headers and coinbase transactions, allowing for validation of
authenticated inclusion and index proofs used to notify users of their
wallet balance, history and current activity, but not revealing other
user’s balances or transaction history.

By using newly added introspective opcodes to construct scripts
dependent on external chains, it is possible for private transactions
to be conditional on public Freicoin blockchain data or other private
accounting servers.

Note that the opposite relation cannot apply at this time.. Public
chains could support transactions conditional to data on other chains
to enhance cross-chain trade, but then the observing chain’s
validation becomes dependent on the observed chain validation. This
approach to cross-chain has been described several times [fn:mdc], and
would be trivial to implement with this protocol extension.

* Proposed changes

** Unlimited-precision fractional arithmetic

All internal computation of accounting quantities are performed using
arbitrary precision fractions, or an equivalent mathematical system
which does not suffer from loss of precision or over/underflow.

*** MAX_MONEY / MoneyRange limitation

The maximum numerical value allowed for any output or stored
intermediary value of any asset type is 2^53 - 1 kria, or
9.007199254740991 x 10^384. This is about 10% less than the maximum
value representable in the =decimal64= type. A transaction which
violates this constraint is invalid.

** IEEE 754-2008 decimal floating point

Output amounts for ~nVersion=3~ transactions are positive, real
decimal floating point values using a stricter subset of the binary
integer decimal encoding specified by IEEE 754-2008. Infinities and
not-a-numbers are not allowed, and the normal (lowest exponent)
representation must be used. For ~nVersion=1~ and ~nVersion=2~
transactions, the =int64= =nValue= field is interpreted according to
the following equation:

#+BEGIN_SRC bitcoin
    nValue :: int64
    dValue :: decimal64
    dValue = nValue * 10369
#+END_SRC

That is to say, an old-style minimum representable positive value of 1
kria (0.00000001 freicoins) would be encoded as a new-style
=decimal64= value of 10^369. Since the smallest representable positive
=decimal64= value is 10^{-398}, that gives an expressive range of
approximately 768 orders of magnitude in the exponent, plus sixteen
digits of precision. While not technically providing infinite
divisibility, there is plenty of room at the bottom.

** Indivisible tokens

New-style outputs contain the =decimal64= continuous value combined
with a possibly empty list of bitstrings. These bitstrings are
indivisible, unique outputs. Any output token must be found in an
input of the enclosing transaction, and tokens cannot be shared among
two outputs of the same transaction.

The asset definition transaction, or any transaction with one or more
of an asset’s issuers as signatory is allowed to violate the
constraint that continuous outputs are less than or equal to inputs,
and that output unique tokens are a subset of inputs for that asset.

** Asset tags

New-style outputs are tagged with a 160 bits identifying the asset
from which the output is drawn. This tag is the 20-byte serialized
hash (~ripemd160 . sha256~) of the asset definition transaction. For
outputs of the host currency Freicoin, the similarly-calculated
20-byte hash of the genesis block is used instead.

** Granular outputs

The granularity option of the asset definition determines the minimum
increment which may be used to transfer an otherwise continuous value.
It is represented as a positive =decimal64= value. If left
unspecified, an asset is limited at this time to the minimum encodable
positive =decimal64= value (10^{-398}), but with further subdivision
allowed if future extensions enable it. The host currency Freicoin is
defined to be maximally divisible in this way. For assets with
non-zero interest/demurrage, granularity checks are made at the
reference-height of the transaction.

** Granular redemption

In general, outputs are considered spent only when the full amount has
been claimed. If a later transaction claims less than the full amount,
that amount is subtracted from the remaining balance.

A transaction may claim less than the full amount by utilizing a
granular offer. The signed offer contains a 64-bit integer field
=nGranularity= which specifies the number of equal-sized units the
offer is split into, and any transaction making use of the offer may
choose the number of units to use, so long as there remains sufficient
output remaining.

In order to implement this functionality, the set of unspent
transaction outputs must include a field recording the amount
remaining (or equivalently, the amount spent so far).

Fractional redemption of outputs containing unique tokens is not
allowed.

** Validation scripts

New-style transactions have a validation script, split into the two
fields =scriptValidPubKey= and =scriptValidSig=, which when combined
and executed must run to completion without abnormal termination, and
return a non-zero value on the stack for a transaction to be valid.

While performing signature operations in any other script, the
=scriptValidSig= is set to the empty script before performing hash
serialization and the =scriptValidPubKey= is stripped of any code
prior to (and including) the last =DELEGATION_SEPARATOR=, if one
exists.

As a special case, an empty =scriptValidPubKey= and =scriptValidSig=
automatically passes, and for an old-style ~nVersion=1~ or
~nVersion=2~ transaction, the empty script is the value of these
fields.

** Authorizing signatories

New-style transactions have a sorted list of ~<assetid:token,
scriptSig>~ signatories. The =assetid= is the 20-byte asset tag, with
a token bitstring taking the remaining bytes. The =scriptPubKey= is
retrieved from the unspent transaction output containing the
identified authorizing token.

** TODO New scripting opcodes

*** TODO =BLOCK_TIME= and =BLOCK_HEIGHT=
*** TODO =DELEGATION_SEPARATOR=
*** TODO =OUT_EXISTS=
*** TODO =OUT_SPENT=

** Transaction expiration

=nExpireTime= works in a very similar way than =nLockTime=, mandating
in this case a maximum time (also specified in either unix time or
block height), after which the transaction cannot be accepted into a
block.

See [[https://en.bitcoin.it/wiki/Protocol_specification#tx][nLockTime]] in Bitcoin's protocol specification for more details.

* Formal specification
** nVersion=3 transactions

This specification defines a new standard bitcoin transaction type,
~nVersion=3~ transactions (~nVersion=2~ being Freicoin's
reference-height transactions, which this specification extends).
~nVersion=3~ transactions differ syntactically from ~nVersion=2~
transactions in the following ways:

- A possibly-empty sub-transaction list precedes the input list.

- Outputs are prefixed with an asset identifier tag, a 20-byte
  serialized hash (~ripemd160 . sha256~) of the coinbase transaction
  from which the output's coins are derived. Each output contains
  coins and/or tokens from a single asset/currency. For the host
  currency Freicoin, the similarly-calculated 20-byte hash of the
  entire chain's genesis block is used instead; within an asset
  definition transaction, the asset being defined is identified with
  the 0 hash.

- Outputs are suffixed with an optionally empty, sorted list of unique
  token bitstrings.

- An optionally empty sorted-list mapping of ~<assetid:token,
  scriptSig>~ signatories is added immediately following =vout=.

- A new script field, split into two fields =scriptValidPubKey= and
  =scriptValidSig=, is added following the signatories’ list.

- A new 32-bit block-time field, =nExpireTime=, is added immediately
  following =nLockTime=.

The following modifications are made to the validation rules for
nVersion=3 transactions:

1. If a sub-transaction list is present, each nested sub-transaction
   must independently validate, according to the rules for
   sub-transaction validation.

2. Sub-transaction aggregate input and output balances are calculated
   at the sub-transaction’s reference-height, and then time-adjusted
   to the enclosing transaction’s reference-height, before being
   summed together as contributors to that transaction’s aggregate
   balance.

3. The asset tag of each output must reference an asset that still
   has unspent, unpruned transaction outputs. (Coins or tokens may be
   destroyed by sending them to the category of prunable, unspendable
   =scriptPubKey= prefixed by =OP_RETURN=, and if all unspent outputs
   of an asset are so constructed, the asset itself is considered
   destroyed.)

4. For a block-level transaction, each asset/currency must
   independently balance (input coin >= output coin, input tokens
   equal to or a superset of output tokens; the difference if any left
   as a fee to the miner). A transaction which has a signature from a
   token in the asset’s issuers list is exempted from this requirement
   for that particular asset, as are asset definition transactions for
   asset being defined.

5. Each signature in the signatories mapping must reference an
   existing token, execute and run to completion using that token's
   =scriptPubKey= without abnormal termination (with the other
   signatories removed during signature operations) or else the
   transaction does not validate. A script that does not finish
   execution with a non-zero value on the top of the stack is not a
   valid signature, but otherwise does not stop transaction
   validation.

   For example, if an authorizer's signature is required and only one
   such signature is present and it terminates with zero on the top
   of the stack, then the transaction does not validate (error:
   missing authorizer signature). But if there are two such
   authorizer signatures, and at least one of them passes then the
   transaction may still validate.

6. For each asset used in the transaction, if that asset has a
   non-empty list of authorizers, at least one such signature must be
   present in the signatories mapping.

7. The =scriptValidPubKey= and =scriptValidSig= of the block-level
   transaction and each nested sub-transaction at any depth, when
   separately combined and executed must run to completion without
   abnormal termination, and return a non-zero value on the stack for
   a transaction to be valid.

   As a special case, if both =scriptValidPubKey= and =scriptValidSig=
   are empty, the check is skipped for that script.

8. The current time or block height must be less than or equal to the
   transaction's =nExpireTime=, where the single field can be
   interpreted as either a block number or UNIX timestamp in the same
   manner as =nLockTime=.

9. For the purposes of enumeration and indexing, the inputs and the
   outputs of the block-level transaction are counted first, followed
   its sub-transactions in order. This corresponds to a depth-first,
   pre-order traversal of the sub-transaction tree.

10. If the transaction is a coinbase but not the first transaction of
    a block, then extra validation rules for asset definition
    transactions apply.

** Hierarchical sub-transactions

Any nVersion=3 transaction includes an optionally empty nested level
of sub-transactions, serialized in-between the =nVersion= and =vin=
fields. Sub-transactions differ syntactically from regular
transactions in the following ways:

- Sub-transactions are prefixed by a =VARINT= value, =nQuantity=,
  which is required to lie within the semi-closed interval
  =(0, nGranularity]=.

- Sub-transactions are suffixed with a =VARINT= value, =nGranularity=,
  which is required to be non-zero.

Sub-transactions are otherwise similar to regular block-level bitcoin
transactions, but with additional verification rules:

1. Null (coinbase) sub-transaction inputs are not allowed.

2. Inputs and outputs do not need to balance (aggregate input may
   exceed output for any asset).

3. The reference-height of a sub-transaction must be less than or
   equal to its enclosing transaction’s (and greater than or equal to
   each of its inputs and sub-transactions).

4. During script execution, the current frame is the sub-transaction.
   This means that input or output indices are relative to the
   sub-transaction, and signature operations evaluate the hash of the
   sub-transaction only.

5. When performing signature operations within the frame of the
   sub-transaction, =nGranularity= is included in the hash
   serialization whereas =nQuantity= is not.

** Asset definition transactions

The coinbase transaction creating an asset is the asset definition
genesis transaction. Such a transaction has a single nullary input
(thereby marking it as a coinbase), and zero or more ordinary inputs
containing freicoins or other asset tokens of any type, typically used
to supply a fee [fn:coinbase]. The output vector must include outputs
of the newly defined asset (marked by an all-zero asset tag), or else
the asset is immediately considered destroyed.

Here are the ways in which an asset definition transactions differ
from ordinary transaction types:

- Asset definition transactions must not be the first transaction of a
  block, which is reserved for the Freicoin miner coinbase.

- As with the Freicoin miner coinbase, the first input of the
  block-level asset definition coinbase transaction must be nullary
  (=0= /txid/, =INT_MAX= /n/-index).

- Unlike the Freicoin miner coinbase, the asset definition coinbase
  string (the =scriptSig= of the nullary input) is allowed to have a
  length within the closed interval =[0, 65535]=. However the string
  must be script-parseable and meet other criteria specified below.

- The coinbase string contains the asset’s interest/demurrage rate,
  unit granularity, and display scale. These values are =decimal64=,
  =decimal64=, and signed integer, respectfully.

- Other inputs besides the nullary input are allowed.

- An asset definition generating transaction may not hash (ripemd160 .
  sha256) to any extant asset tag unless all asset tokens for the
  previously defined asset have been destroyed by spending to a
  provably unspendable, prunable output (=scriptPubKey= prefixed with
  =OP_RETURN=).

- The 0-hash asset tag refers to the asset being defined, within the
  context of the asset definition transaction only.

- The transaction does not require its own issuer or authorizer
  signatures (the issuer and authorizer lists of the asset being
  defined take effect /after/ the asset definition transaction).

* Example use cases and Bitcoin scripts

** MODIFY Private buy with public funds

Seller constructs private order:

#+BEGIN_SRC bitcoin
in: 100 privB
out: 100 FRC:pubA to seller1
validation scriptPubKey:
    DELEGATION_SEPARATOR OP_DUP OP_HASH160 <accountantB_pkh> OP_EQUALVERIFY OP_CHECKSIGVERIFY
    OP_FROMALTSTACK (expiry) OP_FROMALTSTACK (amount) seller1 pubA FRC_CHAIN_ID OP_OUTPUT_EXISTS_BEFORE
#+END_SRC

...and signs the partial transaction.

The validation script contains =DELEGATION_SEPARATOR=, which is a NOP
as far as the script interpreter is concerned, but marks the part of
the validation script that needs to be signed by the accountant but
not the owners of the inputs in the transaction or sub-transaction,
the rest

Note that there's some data being fetched from the stack. That data
must be set by accountantB or the script will return false if it's not
in the stack. Whoever appears in =CHECKSIGVERIFY= (in this case
accountantB) must sign the full transaction with the complete
validation script, including what's before =DELEGATION_SEPARATOR=.

Note also that the output refers to an external asset (FRC:pubA)
accountantB has no control over. It is ignored for validation purposes
and is only used to specify the exchange rate. If the accountant
cheats the user with the exchange rate, there will be a proof of
fraud.

The payer (who just wants 50 privB) completes the private transaction
with:

#+BEGIN_SRC bitcoin
in: -
out: 50 privB to buyer1
#+END_SRC

The buyer also creates the public transaction:

#+BEGIN_SRC bitcoin
in: 50 pubA
out: 50 pubA to seller1
expiry: 10000
#+END_SRC

...but doesn't sign it. It sends both complete but not signed
transactions to the accountant who reads them and completes the
private validation scriptPubKey with:

#+BEGIN_SRC bitcoin
50 OP_TOALTSTACK 10000 OP_TOALTSTACK
#+END_SRC

Finally accountantB signs it all and fills the sub-tx validation
scriptSig with:

#+BEGIN_SRC bitcoin
<accountantB_sig> <accountantB_pk>
#+END_SRC

If you put the full script ordered together to validate by the script
interpreter you have:

#+BEGIN_SRC bitcoin
<accountantB_sig> <accountantB_pk>
50 OP_TOALTSTACK 10000 OP_TOALTSTACK
DELEGATION_SEPARATOR OP_DUP OP_HASH160 <accountantB_pkh> OP_EQUALVERIFY OP_CHECKSIGVERIFY
OP_FROMALTSTACK OP_FROMALTSTACK seller1 pubA FRC_CHAIN_ID OP_OUTPUT_EXISTS_BEFORE
#+END_SRC

Operations in the stack shouldn't be allowed in the validation
scriptSig for this to be secure.

Now if buyer1 signs the public transaction and it gets into the FRC
chain before height 10000, the private transaction will be valid.
Until that happens or height 10000 is reached the transaction is
considered to be in process and after height 10000 without appearance
of the public one, the private transaction is invalid.

** MODIFY Buying public assets with private assets

The seller constructs the public order:

#+BEGIN_SRC bitcoin
in: 100 pubB
out: 100 accountantA:privA to seller1
validation scriptPubKey:
    DELEGATION_SEPARATOR OP_DUP OP_HASH160 <accountantA_pkh> OP_EQUALVERIFY OP_CHECKSIGVERIFY
#+END_SRC

...and signs the partial transaction.

The payer (who just wants 50 pubB) completes the public transaction
with:

#+BEGIN_SRC bitcoin
in: -
out: 50 pubB to buyer1
expiry: 10000
#+END_SRC

The buyer also creates the private transaction:

#+BEGIN_SRC bitcoin
in: 50 privA
out: 50 privA to seller1
validation scriptPubKey:
    10000 50 buyer1 pubB FRC_CHAIN_ID OP_OUTPUT_EXISTS_BEFORE
#+END_SRC

The buyer signs the private transaction and sends it with the public
one to accountantA. The public transaction only lacks accountantA's
signature to be valid. If the public transaction gets into the chain
before 10000 the private one is also valid, otherwise is rolled back.

** MODIFY Hybrid Transitive transaction

    pubA -> pubB -> privC -> privD -> pubE -> userA

So the payer (userA) will pay pubA and receive pubE in exchange.
PrivCs and privDs are managed by accountants accC and accD
respectively.

Opened offers:

   1 ) Fully public:

#+BEGIN_SRC bitcoin bitcoin
in: 100 pubB
out: 100 pubA to userB
#+END_SRC

   2 ) Private for Public:

#+BEGIN_SRC bitcoin
in: 100 privC
out: 100 FRC:pubB to userC
validation scriptPubKey:
    DELEGATION_SEPARATOR OP_DUP OP_HASH160 <accountantC_pkh> OP_EQUALVERIFY OP_CHECKSIGVERIFY
    OP_FROMALTSTACK (expiry) OP_FROMALTSTACK (amount) userC pubB FRC_CHAIN_ID OP_OUTPUT_EXISTS_BEFORE
#+END_SRC

   3 ) Private for private:

#+BEGIN_SRC bitcoin
in: 100 privD
out: 100 accC:privC to userD
validation scriptPubKey:
    DELEGATION_SEPARATOR OP_DUP OP_HASH160 <accountantC_pkh> OP_EQUALVERIFY OP_CHECKSIGVERIFY
    OP_DUP OP_HASH160 <accountantD_pkh> OP_EQUALVERIFY OP_CHECKSIGVERIFY
#+END_SRC

   4 ) Public for private:

#+BEGIN_SRC bitcoin
in: 100 pubE
out: 100 accD:privD to userE
validation scriptPubKey:
    OP_DUP OP_HASH160 <accountantD_pkh> OP_EQUALVERIFY OP_CHECKSIGVERIFY
#+END_SRC

The payer (userA) who wants to buy 50 pubE for 50 pubA builds the
public transaction (pub_tx) using offers 1 and 4:

#+BEGIN_SRC bitcoin
in:  50 pubA
out: 50 pubB to userC
     50 pubE to userA
expiry: 10000
#+END_SRC

Since 50 pubB from offer 1 are used to pay C, 50 pubA must go to
userB, and those are funded by userA in the inputs so sub-tx 1 is
complete and valid. But offer 4 still requires accD to sign the full
transaction. UserA still hasn't provided the scriptSig to access those
50 pubA in the inputs neither.

Two private transactions need to be created:

Using offer 2, the payer also builds transaction priv_tx_1:

#+BEGIN_SRC bitcoin
in: -
out: 50 privC to userD
#+END_SRC

The validation scriptPubKey for 2 must be completed pushing 50 as the
amount and 10000 as the expiry into the stack. The validity of offer 2
and thus this whole transaction still depends on accC's signature.

The other private transaction (priv_tx_2) is built using offer 3:

#+BEGIN_SRC bitcoin
in: -
out: 50 privD to userE
validation scriptPubKey:
    10000 50 userC pubB FRC_CHAIN_ID OP_OUTPUT_EXISTS_BEFORE
#+END_SRC

Offer 3 doesn't require any completion for its validation
scriptPubKey, but the corresponding scriptSig requires the signatures
of both accC and accD.

Now that all transactions are complete, it's time to sign.

First accC signs priv_tx_1 and shares with userA and accD. This is
secure because priv_tx_1 still depends 50 pubB being sent to userC.

UserD is secure because priv_tx_2 in which he gives privD will only be
valid if priv_tx_1 is valid too, that is, if 50 pubB are sent to userC
before expiry as the validation scriptPubKey of priv_tx_2 requires. So
accC and accD can sign offer 3 in any order to make priv_tx_2 almost
valid.

Now accD signs pub_tx to make offer 4 valid.

Only userA's signature for the 50 pubA input is missing. The payer
(userA) signs the full transaction and broadcasts. If it gets into the
block before expiry, all transactions are valid, otherwise all of them
are invalid.

At any point, accC, accD or even userA right before the end could stop
signing and forwarding the transactions, but that would only cause all
transaction to expire.

** TODO Several private assets with blockchain commit method
** TODO Several private assets with registry commit method
** TODO Simplified cross-chain trade contract

* Footnotes

[fn:colored] Colored coins approach to custom assets in the chain is
to define a genesis transaction that identifies the asset and trace
the funds in that transaction outside of the chain to treat them
differently as they represent more than regular bitcoins. This
approach has several limitations when compared to this protocol
extension. There's a discussion group on colored coins development
here: https://groups.google.com/forum/#!forum/bitcoinx

[fn:utxo] Having a fast access UTXO tree indexed in each block would
enhance light clients security and it is also important for
scalability, something important for this proposal since it enables
new uses and a bigger volume is to be expected. Mark Friedenbach's
work on these improvements is documented here: http://utxo.tumblr.com/

[fn:kyc] Issuers of currencies convertible to fiat may have to comply
with know your customer regulations in their jurisdiction for
Ant-Money laundering enforcement. For example, usd gateways based on
the US need to comply with [[http://fincen.gov/statutes_regs/guidance/html/FIN-2013-G001.html][FinCEN's normative]].

[fn:mdc] At least this two threads describe this cross-chain trade
scheme: https://bitcointalk.org/index.php?topic=31643.0
https://bitcointalk.org/index.php?topic=91843.0

[fn:coinbase] This is in contrast to regular coinbase transactions
which do not currently allow extra inputs.
