#+TITLE: FreiMarkets: credit, assets, and p2p exchange
#+AUTHOR:      
#+EMAIL:       
#+KEYWORDS: p2p exchange, crypto-assets, crypto-credit, smart property, colored coins, ripple, off-chain transactions, cross-chain trade
#+LANGUAGE: en
#+LaTeX_CLASS: article
#+LATEX_HEADER: \usepackage[T1]{fontenc}
#+LATEX_HEADER: \usepackage[margin=2.5cm,includefoot]{geometry}
#+LATEX_HEADER: \usepackage{graphicx}
#+LATEX_HEADER: \usepackage{pict2e}
#+LATEX_HEADER: \usepackage{amsmath}
#+LATEX_HEADER: \usepackage{chngcntr}
#+LATEX_HEADER: \usepackage{hyperref}
#+LATEX_HEADER: \usepackage{import}
#+LATEX_HEADER: \hypersetup{colorlinks,citecolor=green,filecolor=black,linkcolor=blue,urlcolor=blue}
#+OPTIONS:     toc:nil H:5
#+BIND: org-export-latex-title-command ""

#+TODO: TODO MODIFY DELETE | REVIEW DONE

Adding arbitrary, user-specified bearer instruments, atomic trades and transitive transactions to Freicoin

* REVIEW Introduction

  Herein we propose a new transaction format, nVersion=3 transactions, which enable hierarchies of independently verified sub-transactions, additional validation scripts and introspective opcodes, strict currency controls, as well as relaxation of the rules regarding coin generation via coinbase transactions for the purpose of supporting user-defined assets on the block-chain. It also introduces the concept of private centralized accounting servers to perform transactions of off-chain assets that cam interact with each other as well as with in-chain assets. Combined with suitable extensions to the peer-to-peer, JSON-RPC, RESTful, and wallet interfaces, these protocol changes complete bitcoin’s repertoire of low-level constructs, allowing the emulation of a wide variety of financial instruments.

  Together this enables the following sorts of applications:

- Issuing new assets by means of asset definition transactions (coinbase transactions other than the usual first transaction of a block). Such assets are allowed to specify their own adjustable interest/demurrage rate, and reference an external legal contract (typically governing their redemption).

- Issuing unique and indivisible assets that are transferred in sets instead of amounts and allow fast look ups on their current ownership to enhance some smart property use cases and manage some permissions of the regular custom assets.

- Atomic exchange of assets of differing types through inclusion of inputs and outputs of both types in a single transaction.

- Signing orders (partial-transactions giving up one asset in exchange for another) that are binding but not completed until they get into the chain as part of a balanced transaction, and have attached expiration dates or can be explicitly cancelled by double-spending the signed inputs.

- Executing an arbitrary number of these orders atomically by creating a complete valid transaction where the orders are included as nested sub-transactions, thereby executing an atomic trade without requiring each of the parties to be online or in direct contact with each other. Composing orders from separate markets into an atomic trade with intermediate assets enables payments based on transitive trust relationships.

- Destruction of coins or assets when no longer needed by a special class of non-spendable, prunable output script.

- Restricting the conditions by which a transaction or sub-transaction may be selected for inclusion in a block by specifying validation scripts, which are run when a the enclosing block is validated.

- Introspection of the block chain from within the bitcoin scripting environment through the use of new opcodes.

- Running accounting servers as private chains without proof of work in which off-chain assets can be issued, transferred and traded in the same way they are in the public chain.

- Execute an arbitrary number of trades from different accounting servers and/or the public chain in an atomic transaction using the public chain as the base for the secure commit.

- Execute an arbitrary number of trades from different accounting servers but not assets in public chains using an agreed upon centralized timestamping server for the commit.

- A chain implementing this modifications can "observe" other chain to enable much faster but secure cross-chain trade without exchanging the hash any secret. This requires the chain to validate all the observed chains in order to validate some conditional transactions.

- Restrict the usage of a custom asset by associating it to indivisible assets that must sign all transactions involving those assets to authorize them (support for KYC compliance).

  This proposal adds primitives to bitcoin necessary for implementing non-currency financial constructs, such as dividend-yielding bonds, asset ownership tokens, credit relationships, a variety of forms of smart contracts, and distributed marketplaces for exchanging all of the above.

  Off-chain assets provide a mechanism to support unlimited volume while being able to interact with in-chain assets in an integrated p2p market.

* REVIEW Description

  Here we describe in non-normative prose the proposed changes. We assume technical familiarity with the bitcoin protocol and Freicoin’s various extensions thereof.  

** Unique assets

   Unique indivisible assets (or just "uniques" or "indivisibles") are good for things like physical ownership - keys to a smart car, numbered seats or membership tokens. Since they directly relate in the UTXO a given unique asset with its current ownership, it's not necessary anymore to trace the ownership back to a "genesis transaction" like you would need to do with a colored coins approach [fn:colored]. This allows smart property clients to have smaller requirements if the UTXO tree is hashed with each block [fn:utxo].

** Asset definition transactions

   Coins representing user-specified assets may be minted in special coinbase transactions apart from the usual first transaction of a block (where freicoins are currently and continue to be minted). Coins created in such generating transactions are not freicoins, but rather user-issued tokens or asset tokens which represent shares of the underlying asset type. Such tokens can be included in transactions containing regular Freicoin currency, which in this document is sometimes called the host currency.

   The issuer of the new asset can define an interest/demurrage rate. The quantity issued may be fixed or he may define a list of issuance unique assets that permit their owners issue new units of the defined asset. Using uniques to manage new issuance allows the issuer to easily cycle public keys and not sign too many times with the same key, since that could be used for certain crypto attacks.

   Another thing that issuers/gateways can define is a list of authority uniques. The signature of an authority unique is required every time any funds of that asset are to be moved or created. This allows issuers/gateways to manage closed list of "authorized accounts" of registered users if their jurisdiction requires them to do so [fn:kyc] or just want to have users in a local area (local currencies). It also allows issuers to charge fees when the assets are traded or moved.

   The coinbase string is used to specify or update the interest/demurrage rate, the external contract hash, a varlist of issuance uniques and a varlist of authority uniques. Either one, all, or none may be specified for a given asset, and are serialized in the coinbase string.

** Private chains

   Private ledgers use a variant of the Freicoin/Freimarkets code base that is stripped of proof-of-work.

   Accountants for private ledgers are responsible for taking care of double-spending. Accountants are able to prevent transactions from going through if the owner has already obligated funds elsewhere - by keeping track of the available balance (actual balance - funds in various stages of commit). Accountants use various mechanisms for coordination among each other (register, blockchain commit, etc.)

   The level of privacy may vary from one server to another. Maybe a server publishes blocks signed by a unique under his control at periodic intervals while another only gives the user the proofs of his own balances. In that case users can not only ask accountants for their balances but for the full property chain of signatures back to issuance.

   Note on asymmetry: it is possible for private transactions to be conditional on public Freicoin blockchain data, but not vice versa. 

   Public chains could support transactions conditional to data on other chains to enhance cross-chain trade, but then the observing chain's validation becomes dependent on the observed chain validation. This approach to cross-chain has been described several times and would be trivial to implement with this protocol extension.

* TODO Formal specification
** nVersion=3 transactions
** Unique asset definitions and transfers
indivisibles : the simplist method is for outputs to contain instead of an int64 nValue, a decimal64 nValue + varlist(uniques)
** Asset definition transactions
** Sub-transactions
** Validation scripts
** New scripting opcodes
* Example use cases and Bitcoin scripts
** MODIFY Private buy with public funds
   Seller constructs private order:

#+BEGIN_SRC bitcoin
in: 100 privB
out: 100 FRC:pubA to seller1
validation scriptPubKey: 
    OP_DELEGATION_SEPARATOR OP_DUP OP_HASH160 <accountantB_pkh> OP_EQUALVERIFY OP_CHECKSIGVERIFY_DEL
    OP_FROMALTSTACK (expiry) OP_FROMALTSTACK (amount) seller1 pubA FRC_CHAIN_ID OP_OUTPUT_EXISTS_BEFORE
#+END_SRC

   ...and signs the partial transaction. 

   The validation script starts with OP_DELEGATION_SEPARATOR, which is simply ignored by the script interpreter, but marks the part of the validation script that needs to be signed by the owners of the inputs in the transaction or sub-transaction, the rest 
   
   Note that there's some data being fetch from the stack, that data must be set by accountantB or the script will return false if it's not in the stack. Whoever appears in OP_CHECKSIGVERIFY_DEL (in this case accountantB) must sign the full transaction with the complete validation script that can be valid, including what's after OP_DELEGATION_SEPARATOR.

   Note also that he output refers to an external asset (FRC:pubA) accountantB has no control over. It is ignored for validation purposes and is only used to specify the exchange rate. If the accountant cheats the user with the exchange rate, there will be a proof of fraud.

   The payer (who just wants 50 privB) completes the private transaction with:

#+BEGIN_SRC bitcoin
in: -
out: 50 privB to buyer1
#+END_SRC

   The buyer also creates the public transaction:

#+BEGIN_SRC bitcoin
in: 50 pubA
out: 50 pubA to seller1
expiry: 10000
#+END_SRC

   ...but doesn't sign it. It sends both complete but not signed transactions to the accountant who reads them and completes the private validation scriptPubKey with:

#+BEGIN_SRC bitcoin
50 OP_TOALTSTACK 10000 OP_TOALTSTACK
#+END_SRC

   Finally accountantB signs it all and fills the sub-tx validation scriptSig with:

#+BEGIN_SRC bitcoin
<accountantB_sig> <accountantB_pk>
#+END_SRC

   If you put the full script ordered together to validate by the script interpreter you have:

#+BEGIN_SRC bitcoin
<accountantB_sig> <accountantB_pk>
50 OP_TOALTSTACK 10000 OP_TOALTSTACK
OP_DELEGATION_SEPARATOR OP_DUP OP_HASH160 <accountantB_pkh> OP_EQUALVERIFY OP_CHECKSIGVERIFY_DEL
OP_FROMALTSTACK OP_FROMALTSTACK seller1 pubA FRC_CHAIN_ID OP_OUTPUT_EXISTS_BEFORE
#+END_SRC

   Operations in the stack shouldn't be allowed in the validation scriptSig for this to be secure.

   Now if buyer1 signs the public transaction and it gets into the FRC chain before height 10000, the private transaction will be valid. Until that happens or height 10000 is reached the transaction is considered to be in process and after height 10000 without appearance of the public one, the private transaction is invalid. 

** MODIFY Buying public assets with private assets

   The seller constructs the public order:

#+BEGIN_SRC bitcoin
in: 100 pubB
out: 100 accountantA:privA to seller1
validation scriptPubKey: 
    OP_DELEGATION_SEPARATOR OP_DUP OP_HASH160 <accountantA_pkh> OP_EQUALVERIFY OP_CHECKSIGVERIFY_DEL
#+END_SRC

   ...and signs the partial transaction. 

   The payer (who just wants 50 pubB) completes the public transaction with:

#+BEGIN_SRC bitcoin
in: -
out: 50 pubB to buyer1
expiry: 10000
#+END_SRC

   The buyer also creates the private transaction:

#+BEGIN_SRC bitcoin
in: 50 privA
out: 50 privA to seller1
validation scriptPubKey: 
    10000 50 buyer1 pubB FRC_CHAIN_ID OP_OUTPUT_EXISTS_BEFORE
#+END_SRC

   The buyer signs the private transaction and sends it with the public one to accountantA.
The public transaction only lacks accountantA's signature to be valid. If the public transaction gets into the chain before 10000 the private one is also valid, otherwise is rolled back.

** MODIFY Hybrid Transitive transaction

   pubA -> pubB -> privC -> privD -> pubE -> userA

   So the payer (userA) will pay pubA and receive pubE in exchange. PrivCs and privDs are managed by accountants accC and accD respectively.

Opened offers:

   1 ) Fully public:

#+BEGIN_SRC bitcoin bitcoin
in: 100 pubB
out: 100 pubA to userB
#+END_SRC

   2 ) Private for Public:

#+BEGIN_SRC bitcoin
in: 100 privC
out: 100 FRC:pubB to userC
validation scriptPubKey: 
    OP_DELEGATION_SEPARATOR OP_DUP OP_HASH160 <accountantC_pkh> OP_EQUALVERIFY OP_CHECKSIGVERIFY_DEL
    OP_FROMALTSTACK (expiry) OP_FROMALTSTACK (amount) userC pubB FRC_CHAIN_ID OP_OUTPUT_EXISTS_BEFORE
#+END_SRC

   3 ) Private for private:

#+BEGIN_SRC bitcoin
in: 100 privD
out: 100 accC:privC to userD
validation scriptPubKey: 
    OP_DELEGATION_SEPARATOR OP_DUP OP_HASH160 <accountantC_pkh> OP_EQUALVERIFY OP_CHECKSIGVERIFY_DEL
    OP_DUP OP_HASH160 <accountantD_pkh> OP_EQUALVERIFY OP_CHECKSIGVERIFY_DEL
#+END_SRC

   4 ) Public for private:

#+BEGIN_SRC bitcoin
in: 100 pubE
out: 100 accD:privD to userE
validation scriptPubKey: 
    OP_DUP OP_HASH160 <accountantD_pkh> OP_EQUALVERIFY OP_CHECKSIGVERIFY_DEL
#+END_SRC

   The payer (userA) who wants to buy 50 pubE for 50 pubA builds the public transaction (pub_tx) using offers 1 and 4:

#+BEGIN_SRC bitcoin
in:  50 pubA
out: 50 pubB to userC
     50 pubE to userA
expiry: 10000
#+END_SRC

   Since 50 pubB from offer 1 are used to pay C, 50 pubA must go to userB, and those are funded by userA in the inputs so sub-tx 1 is complete and valid.
   But offer 4 still requires accD to sign the full transaction. UserA still hasn't provided the scriptSig to access those 50 pubA in the inputs neither.

   Two private transactions need to be created:

   Using offer 2, the payer also builds transaction priv_tx_1:

#+BEGIN_SRC bitcoin
in: -
out: 50 privC to userD
#+END_SRC

   The validation scriptPubKey for 2 must be completed pushing 50 as the amount and 10000 as the expiry into the stack. The validity of offer 2 and thus this whole transaction still depends on accC's signature.

   The other private transaction (priv_tx_2) is built using offer 3:

#+BEGIN_SRC bitcoin
in: -
out: 50 privD to userE
validation scriptPubKey:
    10000 50 userC pubB FRC_CHAIN_ID OP_OUTPUT_EXISTS_BEFORE
#+END_SRC

   Offer 3 doesn't require any completion for its validation scriptPubKey, but the corresponding scriptSig requires the signatures of both accC and accD.

   Now that all transactions are complete, it's time to sign.

   First accC signs priv_tx_1 and shares with userA and accD. This is secure because priv_tx_1 still depends 50 pubB being sent to userC.

   UserD is secure because priv_tx_2 in which he gives privD will only be valid if priv_tx_1 is valid too, that is, if 50 pubB are sent to userC before expiry as the validation scriptPubKey of priv_tx_2 requires. So accC and accD can sign offer 3 in any order to make priv_tx_2 almost valid.

   Now accD signs pub_tx to make offer 4 valid.

   Only userA's signature for the 50 pubA input is missing. The payer (userA) signs the full transaction and broadcasts. If it gets into the block before expiry, all transactions are valid, otherwise all of them are invalid.

   At any point, accC, accD or even userA right before the end could stop signing and forwarding the transactions, but that would only cause all transaction to expire.

** TODO Several private assets with blockchain commit method
** TODO Several private assets with registry commit method
** TODO Simplified cross-chain trade contract

* Footnotes

[fn:colored] Colored coins approach to custom assets in the chain is to define a genesis transaction that identifies the asset and trace the funds in that transaction outside of the chain to treat them differently as they represent more than regular bitcoins. This approach has several limitations when compared to this protocol extension. There's a discussion group on colored coins development here: https://groups.google.com/forum/#!forum/bitcoinx

[fn:utxo] Having a fast access UTXO tree indexed in each block would enhance light clients security and it is also important for scalability, something important for this proposal since it enables new uses and a bigger volume is to be expected. Mark Friedenbach's work on these improvements is documented here: http://utxo.tumblr.com/

[fn:kyc] Issuers of currencies convertible to fiat may have to comply with know your customer regulations in their jurisdiction for Ant-Money laundering enforcement. For example, usd gateways based on the US need to comply with [[http://fincen.gov/statutes_regs/guidance/html/FIN-2013-G001.html][FinCEN's normative]].


